using log;
using slice;
using hex;
using buffer;
using byteorder;
using err;
using mem;
using <string.h>::{memmove};
using madpack;
using json;
using <stdio.h>::{fread, stdin,stderr, stdout, printf, fopen, fclose, FILE, fwrite};


export fn main(int argc, char ** argv) -> int
    where (usize)argc < len(argv)
{
    new+1000 e = err::make();

    new+1000000 bi = buffer::make();
    new+100000 idx = madpack::empty_index();

    bool mut mode_unpack = false;
    bool mut mode_index_make = false;


    for (usize mut i = 1; i < (usize)argc; i++) {
        if unsafe<bool>(buffer::cstr_eq(argv[i], "--unpack")) {
            mode_unpack = true;
        } else if unsafe<bool>(buffer::cstr_eq(argv[i], "--index")) {
            i += 1;
            err::assert(i < (usize)argc);

            FILE mut* fd = (FILE mut *)fopen(argv[i], "r");
            if fd == 0 {
                err::panic("cannot open %s", argv[i]);
            }
            while bi.fread(fd) {};
            fclose(fd);
            madpack::from_preshared_index(&idx, bi.as_slice());
            bi.clear();

        } else if unsafe<bool>(buffer::cstr_eq(argv[i], "--make-index")) {
            mode_index_make = true;
        } else {
            printf(r#"usage:  madpack [options]
  default:          json (stdin) to madpack (stdout)
  --unpack:         madpack (stdin) to json (stdout)
  --index <file>:   use preshared index to (un)pack
"#);
            return 2;

        }
    }


    while bi.fread(stdin) {};



    if mode_unpack {
        new dc = madpack::decode(bi.as_slice(), &idx);
        madpack2json(&dc, false, 0);
        printf("\n");
    } else {

        new+200000 bo = buffer::make();
        new enc = madpack::encode(bo.as_mut_slice(), &idx);


        new+160000 dec = json::decode_value(&e, bi.mem, bi.at);
        e.abort();
        json2madpack(&dec, &enc, &e);
        e.abort();

        if mode_index_make {
            bo.clear();
            idx.to_preshared_index(bo.as_mut_slice(), &e);
            e.abort();
            fwrite(bo.mem, 1, bo.at, stdout);
        } else {
            log::info("encoded %d bytes of json into %d bytes of madpack", bi.at, bo.at);
            fwrite(bo.mem, 1, bo.at, stdout);
        }
    }


    return 0;
}


fn madpack2json(madpack::Decoder mut * dc, bool ismap, usize indent)
{
    bool mut first = true;
    for (;;) {
        if ismap {
            if !dc->next_kv() {
                break;
            }
        } else {
            if !dc->next_v() {
                break;
            }
        }
        if dc->item == madpack::Item::End {
            break;
        }
        if first {
            first = false;
            printf("\n");
        } else {
            printf(",\n");
        }
        for (usize mut i = 0; i < indent; i++) {
            printf("  ");
        }
        if ismap {
            printf("\"%.*s\" : ", dc->key.size, dc->key.mem);
        }
        switch dc->item {
            madpack::Item::Invalid   => {
                printf("\"invalid\"");
            }
            madpack::Item::Null      => {
                printf("null");
            }
            madpack::Item::True      => {
                printf("true");
            }
            madpack::Item::False     => {
                printf("false");
            }
            madpack::Item::Float     => {
                printf("%f", dc->value.v_float);
            }
            madpack::Item::Uint      => {
                printf("%llu", dc->value.v_uint);
            }
            madpack::Item::Sint      => {
                printf("%d", dc->value.v_sint);
            }
            madpack::Item::String    => {
                printf("\"%.*s\"", dc->value.v_slice.size, dc->value.v_slice.mem);
            }
            madpack::Item::Bytes     => {
                printf("\"bytes\"");
            }
            madpack::Item::Map       => {
                printf("{");
                madpack2json(dc, true, indent + 1 );
                printf("\n");
                for (usize mut i = 0; i < indent; i++) {
                    printf("  ");
                }
                printf("}");
            }
            madpack::Item::Array     => {
                printf("[");
                madpack2json(dc, false, indent + 1 );
                printf("\n");
                for (usize mut i = 0; i < indent; i++) {
                    printf("  ");
                }
                printf("]");
            }
        }
    }
}

fn json2madpack(json::Decoder mut *dec, madpack::Encoder mut * enc,  err::Err mut *e)
    where err::checked(*e)
    where madpack::integrity(enc)
{
    while dec->next(e) {
        switch dec->item {
            json::Item::Array => {
                if dec->key.mem != 0 {
                    enc->kv_array(dec->key);
                } else {
                    enc->v_array();
                }
                json2madpack(dec, enc, e);
            }
            json::Item::Map => {
                if dec->key.mem != 0 {
                    enc->kv_map(dec->key);
                } else {
                    enc->v_map();
                }
                json2madpack(dec, enc, e);
            }
            json::Item::DirtyString => {
            }
            json::Item::String => {
                if dec->key.mem != 0 {
                    enc->kv_strslice(dec->key, dec->val);
                } else {
                    enc->v_strslice(dec->val);
                }
            }
            json::Item::Uint => {
                let v = dec->val.atoi(10);
                if dec->key.mem != 0 {
                    enc->kv_uint(dec->key, v);
                } else {
                    enc->v_uint(v);
                }
            }
            json::Item::False => {
                if dec->key.mem != 0 {
                    enc->kv_bool(dec->key, false);
                } else {
                    enc->v_bool(false);
                }
            }
            json::Item::True => {
                if dec->key.mem != 0 {
                    enc->kv_bool(dec->key, true);
                } else {
                    enc->v_bool(true);
                }
            }
            json::Item::Null => {
                if dec->key.mem != 0 {
                    enc->kv_null(dec->key);
                } else {
                    enc->v_null();
                }
            }
        }
    }
    enc->end();
}
