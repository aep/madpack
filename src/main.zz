using log;
using slice;
using hex;
using buffer;
using byteorder;
using err;
using mem;
using <string.h>::{memmove};
using madpack;
using json;
using <stdio.h>::{fread, stdin,stderr, stdout, printf, fopen, fclose, FILE, fwrite};


export fn main(int argc, char ** argv) -> int
    where (usize)argc < len(argv)
{
    new+1000 e = err::make();

    new+1000 idx = madpack::empty_index();

    bool mut mode_unpack = false;
    bool mut mode_index_make = false;

    for (usize mut i = 1; i < (usize)argc; i++) {
        if unsafe<bool>(buffer::cstr_eq(argv[i], "--unpack")) {
            mode_unpack = true;
        } else if unsafe<bool>(buffer::cstr_eq(argv[i], "--index")) {
            i += 1;
            err::assert(i < (usize)argc);

            FILE mut* fd = (FILE mut *)fopen(argv[i], "r");
            if fd == 0 {
                err::panic("cannot open %s", argv[i]);
            }

            new+20000 b = buffer::make();
            for(;;) {
                char mut buf[1000];
                usize bin = as<usize>(fread(buf, sizeof(char), static(len(buf)), fd));
                if bin == 0 {
                    break;
                }
                static_attest(bin < len(buf));
                b.append_bytes((u8*)buf, bin);
            }

            fclose(fd);
            madpack::from_preshared_index(&idx, b.as_slice());

        } else if unsafe<bool>(buffer::cstr_eq(argv[i], "--make-index")) {
            mode_index_make = true;
        } else {
            printf(r#"usage:  madpack [options]
  default:          json (stdin) to madpack (stdout)
  --unpack:         madpack (stdin) to json (stdout)
  --index <file>:   use preshared index to (un)pack
"#);
            return 2;

        }
    }


    if mode_unpack {
        new+20000 b = buffer::make();
        for(;;) {
            char mut buf[1000];
            usize bin = as<usize>(fread(buf, sizeof(char), static(len(buf)), stdin));
            if bin == 0 {
                break;
            }
            static_attest(bin < len(buf));
            b.append_bytes((u8*)buf, bin);
        }

        printf("{");
        new dc = madpack::decode(b.as_slice(), &idx);
        json_decode(&dc, true, 1);
        printf("\n}\n");

    } else {

        new+20000 b = buffer::make();
        new enc = madpack::encode(b.as_mut_slice(), &idx);

        new+1000 parser = json::parser(&e, json::U{
            it:     json_encode,
            user1:  &enc,
            user2:  1,
        });
        e.abort();

        char mut buf[1000];
        for(;;) {
            usize bin = as<usize>(fread(buf, sizeof(char), static(len(buf)), stdin));
            if bin == 0 {
                break;
            }
            static_attest(bin < len(buf));
            json::push(&parser, &e, buf, bin);
            if err::check(&e) {
                err::eprintf(&e, stderr);
                return 2;
            }
        }
        e.abort();
        if mode_index_make {
            let sl = idx.to_preshared_index();
            fwrite(sl.mem, 1, sl.size, stdout);
        } else {
            fwrite(b.mem, 1, b.at, stdout);
        }
    }


    return 0;
}


fn json_decode(madpack::Decoder mut * dc, bool ismap, usize indent)
{
    bool mut first = true;
    for (;;) {
        if ismap {
            if !dc->next_kv() {
                break;
            }
        } else {
            if !dc->next_v() {
                break;
            }
        }
        if dc->item == madpack::Item::End {
            break;
        }
        if first {
            first = false;
            printf("\n");
        } else {
            printf(",\n");
        }
        for (usize mut i = 0; i < indent; i++) {
            printf("  ");
        }
        if ismap {
            printf("\"%.*s\" : ", dc->key.size, dc->key.mem);
        }
        switch dc->item {
            madpack::Item::Invalid   => {
                printf("\"invalid\"");
            }
            madpack::Item::Null      => {
                printf("null");
            }
            madpack::Item::True      => {
                printf("true");
            }
            madpack::Item::False     => {
                printf("false");
            }
            madpack::Item::Float     => {
                printf("%f", dc->value.v_float);
            }
            madpack::Item::Uint      => {
                printf("%llu", dc->value.v_uint);
            }
            madpack::Item::Sint      => {
                printf("%d", dc->value.v_sint);
            }
            madpack::Item::String    => {
                printf("\"%.*s\"", dc->value.v_slice.size, dc->value.v_slice.mem);
            }
            madpack::Item::Bytes     => {
                printf("\"bytes\"");
            }
            madpack::Item::Map       => {
                printf("{");
                json_decode(dc, true, indent + 1 );
                printf("\n");
                for (usize mut i = 0; i < indent; i++) {
                    printf("  ");
                }
                printf("}");
            }
            madpack::Item::Array     => {
                printf("[");
                json_decode(dc, false, indent + 1 );
                printf("\n");
                for (usize mut i = 0; i < indent; i++) {
                    printf("  ");
                }
                printf("]");
            }
        }
    }
}


fn json_encode_end(json::U *u, err::Err+et mut * e, json::Parser+pt mut* p)
    where err::checked(*e)
{
    madpack::Encoder mut*enc = (madpack::Encoder mut *)u->user1;
    err::assert_safe(enc);
    static_attest(madpack::integrity(enc));

    enc->end();
}

fn json_encode(json::U *u, err::Err+et mut *e, json::Parser+pt mut* p, char *k, json::Value v)
    where err::checked(*e)
    where nullterm(k)
{
    madpack::Encoder mut*enc = (madpack::Encoder mut *)u->user1;
    err::assert_safe(enc);
    static_attest(madpack::integrity(enc));

    switch v.t {
        json::ValueType::Object => {

            if u->user2 == 1 {
                if !enc->kv_map(k) {
                    e->fail(err::OutOfTail, "oom");
                }
            } else {
                if !enc->v_map() {
                    e->fail(err::OutOfTail, "oom");
                }
            }

            json::next(p,  e, json::U{
                it:     json_encode,
                user1:  enc,
                user2:  1,
                pop:    json_encode_end,
            });
            if err::check(e) {
                return;
            }

        }
        json::ValueType::Array => {

            if u->user2 == 1 {
                if !enc->kv_array(k) {
                    e->fail(err::OutOfTail, "oom");
                }
            } else {
                if !enc->v_array() {
                    e->fail(err::OutOfTail, "oom");
                }
            }

            json::next(p,  e, json::U{
                it:     json_encode,
                user1:  enc,
                user2:  0,
                pop:    json_encode_end,
            });
            if err::check(e) {
                return;
            }


        }
        json::ValueType::String => {
            static_attest(safe(v.string));
            static_attest(nullterm(v.string));

            if u->user2 == 1 {
                if !enc->kv_cstr(k, v.string) {
                    e->fail(err::OutOfTail, "oom");
                }
            } else {
                if !enc->v_cstr(v.string) {
                    e->fail(err::OutOfTail, "oom");
                }
            }
        }
        json::ValueType::Integer => {
            //TODO uuuh this can be negative
            if u->user2 == 1 {
                if !enc->kv_uint(k, v.integer) {
                    e->fail(err::OutOfTail, "oom");
                }
            } else {
                if !enc->v_uint(v.integer) {
                    e->fail(err::OutOfTail, "oom");
                }
            }
        }
        json::ValueType::Boolean => {
            if u->user2 == 1 {
                if !enc->kv_bool(k, v.integer) {
                    e->fail(err::OutOfTail, "oom");
                }
            } else {
                if !enc->v_bool(v.integer) {
                    e->fail(err::OutOfTail, "oom");
                }
            }
        }
        json::ValueType::Null => {
            if u->user2 == 1 {
                if !enc->kv_null(k) {
                    e->fail(err::OutOfTail, "oom");
                }
            } else {
                if !enc->v_null() {
                    e->fail(err::OutOfTail, "oom");
                }
            }
        }
    }
}
